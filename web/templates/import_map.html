{% extends "base.html" %}
{% block content %}

<style>
  .wrap { max-width:900px; margin:0 auto; }
  .card {
    background:#fff;
    border:1px solid #e5e7eb;
    border-radius:16px;
    padding:18px;
    margin-bottom:18px;
  }
  h2 { margin:0; font-size:22px; font-weight:900; }
  h3 { margin:0; font-size:18px; font-weight:900; }
  .sub {
    margin-top:6px;
    font-size:13px;
    color:#64748b;
  }
  label {
    display:block;
    font-size:13px;
    font-weight:900;
    margin-top:14px;
  }
  select {
    width:100%;
    padding:12px;
    border-radius:12px;
    border:1px solid #d1d5db;
    margin-top:6px;
    background:#fff;
  }
  .btn {
    margin-top:16px;
    padding:12px 16px;
    border-radius:12px;
    border:1px solid #111827;
    background:#111827;
    color:#fff;
    font-weight:900;
    cursor:pointer;
  }
  .muted { font-size:12px; color:#64748b; }
  table {
    border-collapse:collapse;
    width:100%;
    font-size:13px;
  }
  th, td {
    border:1px solid #e5e7eb;
    padding:8px 10px;
    text-align:left;
    vertical-align:top;
  }
  th {
    background:#f9fafb;
    font-weight:900;
  }
  td {
    white-space:nowrap;
    max-width:260px;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  details summary {
    cursor:pointer;
    font-weight:900;
  }
</style>

<div class="wrap">

  <!-- Header -->
  <div class="card">
    <h2>Import CSV – Map columns</h2>
    <div class="sub">
      Match your CSV columns to the correct fields before importing.
      <br>
      Default country: <b>{{ default_country or "US" }}</b>
    </div>
  </div>

  <!-- Mapping form -->
  <div class="card">
    <form id="importForm" method="POST" action="{{ url_for('import_csv_mapped_start') }}">
      <input type="hidden" name="tmp_path" value="{{ tmp_path }}">

      <label>Client name <span class="muted">(required)</span></label>
      <select name="col_name" required>
        <option value="">— choose column —</option>
        {% for h in headers %}<option value="{{ h }}">{{ h }}</option>{% endfor %}
      </select>

      <label>Email <span class="muted">(required)</span></label>
      <select name="col_email" required>
        <option value="">— choose column —</option>
        {% for h in headers %}<option value="{{ h }}">{{ h }}</option>{% endfor %}
      </select>

      <label>Description <span class="muted">(optional)</span></label>
      <select name="col_desc">
        <option value="">— none —</option>
        {% for h in headers %}<option value="{{ h }}">{{ h }}</option>{% endfor %}
      </select>

      <label>Due date <span class="muted">(optional)</span></label>
      <select name="col_due">
        <option value="">— none —</option>
        {% for h in headers %}<option value="{{ h }}">{{ h }}</option>{% endfor %}
      </select>

      <label>Preferred channel for imported rows</label>
      <select name="preferred_channel">
        <option value="email" selected>Email</option>
      </select>

      <button id="importBtn" type="submit" class="btn">
        Import CSV
      </button>

      <!-- Progress bar -->
      <div id="progressWrap" style="display:none; margin-top:16px;">
        <div style="font-weight:900; margin-bottom:8px;">
          Importing… <span id="pctText">0%</span>
        </div>
        <div style="height:12px; border:1px solid #e5e7eb; border-radius:999px; overflow:hidden; background:#f8fafc;">
          <div id="bar" style="height:100%; width:0%; background:#111827;"></div>
        </div>
        <div class="muted" style="margin-top:8px;">
          <span id="rowText">0 / 0 rows</span>
        </div>
      </div>
      <!-- /Progress bar -->

    </form>
  </div>

  <!-- Rules -->
  <div class="card">
    <details>
      <summary>CSV rules & tips</summary>
      <div class="muted" style="margin-top:10px; line-height:1.6;">
        • Every row must contain a valid email address.<br>
        • Due dates must be in <code>YYYY-MM-DD</code> format.<br>
        • Rows with missing required fields will be skipped.
      </div>
    </details>
  </div>

  <!-- Preview -->
  <div class="card">
    <h3>Preview (first {{ (preview or [])|length }} rows)</h3>

    <div style="overflow:auto; margin-top:10px;">
      <table>
        <thead>
          <tr>
            {% for h in headers %}<th>{{ h }}</th>{% endfor %}
          </tr>
        </thead>
        <tbody>
          {% for r in (preview or []) %}
          <tr>
            {% for h in headers %}
              <td>{{ r.get(h) }}</td>
            {% endfor %}
          </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </div>

</div>

<script>
  // --- shared app socket (created in base.html) ---
  // expects something like: window.appSocket = io(...); in your base template
  const importSocket = window.appSocket;

  const form = document.getElementById("importForm");
  const btn = document.getElementById("importBtn");
  const progressWrap = document.getElementById("progressWrap");
  const pctText = document.getElementById("pctText");
  const bar = document.getElementById("bar");
  const rowText = document.getElementById("rowText");

  let poll = null;

  function setProgress(pct, done, total) {
    const safePct = Math.max(0, Math.min(100, Number(pct || 0)));
    pctText.textContent = `${safePct}%`;
    bar.style.width = `${safePct}%`;
    if (typeof done === "number" && typeof total === "number") {
      rowText.textContent = `${done} / ${total} rows`;
    }
  }

  function stopPoll() {
    if (poll) {
      clearInterval(poll);
      poll = null;
    }
  }

  function startPoll(jobId) {
    stopPoll();
    poll = setInterval(async () => {
      try {
        const r = await fetch(`/import-csv-mapped/status/${jobId}`, {
          headers: { "X-Requested-With": "fetch" }
        });
        const j = await r.json();
        if (!j.ok) return;

        if (j.job?.status === "done") {
          stopPoll();
          window.location.href = "{{ url_for('dashboard') }}";
        }

        if (j.job?.status === "error") {
          stopPoll();
          alert("Import failed: " + (j.job?.result?.error || "unknown_error"));
          btn.disabled = false;
          btn.style.opacity = "1";
          btn.style.cursor = "pointer";
        }

        // optional: update progress from polling if your status endpoint provides it
        if (j.job?.progress) {
          setProgress(j.job.progress.pct, j.job.progress.done, j.job.progress.total);
        }
      } catch (e) {
        // don't spam alerts; polling might fail transiently
        console.warn("poll error", e);
      }
    }, 1000);
  }

  function wireSocketListeners() {
    if (!importSocket) {
      console.warn("window.appSocket missing, will rely on polling fallback");
      return;
    }

    importSocket.on("connect", () => {
      console.log("✅ app socket connected", importSocket.id);
    });

    importSocket.on("connect_error", (e) => {
      console.error("❌ app socket error", e);
    });

    importSocket.on("import_progress", (payload) => {
      setProgress(payload?.pct, payload?.done, payload?.total);
    });

    importSocket.on("import_done", (payload) => {
      stopPoll();
      setProgress(100, payload?.total ?? 0, payload?.total ?? 0);
      window.location.href = (payload?.redirect || "{{ url_for('dashboard') }}");
    });

    importSocket.on("import_error", (payload) => {
      stopPoll();
      alert("Import failed: " + (payload?.error || payload?.message || "unknown_error"));
      btn.disabled = false;
      btn.style.opacity = "1";
      btn.style.cursor = "pointer";
    });
  }

  wireSocketListeners();

  // ✅ SINGLE submit handler (fetch-based, no reload)
  form.addEventListener("submit", async (e) => {
    e.preventDefault();

    progressWrap.style.display = "block";
    btn.disabled = true;
    btn.style.opacity = "0.7";
    btn.style.cursor = "not-allowed";
    setProgress(0, 0, 0);

    const fd = new FormData(form);

    // try to send socket id if present
    const socketId = importSocket?.id || "";
    fd.append("socket_id", socketId);

    const res = await fetch(form.action, {
      method: "POST",
      body: fd,
      headers: { "X-Requested-With": "fetch" }
    });

    const data = await res.json();
    if (!data.ok) {
      alert(data.error || "Import failed");
      btn.disabled = false;
      btn.style.opacity = "1";
      btn.style.cursor = "pointer";
      return;
    }

    const jobId = data.job_id;
    window.__import_job_id = jobId;

    // join room for this import job
    if (importSocket) {
      importSocket.emit("join_import", { job_id: jobId });
    }

    // polling fallback (also acts as backup if sockets die mid-way)
    startPoll(jobId);
  });
</script>

{% endblock %}
